#!/usr/bin/env python3
"""
Audio Queue Manager

Copyright (c) 2025 TAPSOSS
Project: https://github.com/TAPSOSS/Walrio
Licensed under the BSD-3-Clause License (see LICENSE file for details)

A script that manages a queue of songs from the audio library and plays them using audio_player.py and a db file (assumed to be generated by audio_library.py).
Sample Usage: python audio_queue.py [--db-path <database_path>] [--shuffle] [--repeat] [--artist <artist>] [--album <album>] [--genre <genre>]
"""

import sys
import os
import sqlite3
import argparse
import random
import subprocess
from pathlib import Path
from audio_player import play_audio

# Default database path
DEFAULT_DB_PATH = "walrio_library.db"

# Connect to the SQLite database and return connection
def connect_to_database(db_path):
    if not os.path.exists(db_path):
        print(f"Error: Database file '{db_path}' not found.")
        print("Please run audio_library.py first to create the database.")
        return None
    try:
        conn = sqlite3.connect(db_path)
        conn.row_factory = sqlite3.Row  # Enable dict-like access to rows
        return conn
    except sqlite3.Error as e:
        print(f"Error connecting to database: {e}")
        return None

# Get songs from database based on filters
def get_songs_from_database(conn, filters=None):
    cursor = conn.cursor()
    
    # Base query
    query = """
        SELECT id, title, artist, album, albumartist, url, length, track, disc, year, genre
        FROM songs
        WHERE unavailable = 0
    """
    params = []
    
    # Apply filters if provided
    if filters:
        if filters.get('artist'):
            query += " AND (artist LIKE ? OR albumartist LIKE ?)"
            artist_filter = f"%{filters['artist']}%"
            params.extend([artist_filter, artist_filter])
        
        if filters.get('album'):
            query += " AND album LIKE ?"
            params.append(f"%{filters['album']}%")
        
        if filters.get('genre'):
            query += " AND genre LIKE ?"
            params.append(f"%{filters['genre']}%")
    
    # Order by artist, album, disc, track for logical playback order
    query += " ORDER BY artist, album, disc, track"
    
    try:
        cursor.execute(query, params)
        return cursor.fetchall()
    except sqlite3.Error as e:
        print(f"Error querying database: {e}")
        return []

# Format song information for display
def format_song_info(song):
    artist = song['artist'] or "Unknown Artist"
    albumartist = song['albumartist'] or artist  # Use albumartist if available, otherwise fall back to artist
    title = song['title'] or "Unknown Title"
    album = song['album'] or "Unknown Album"
    
    # Format duration
    duration = ""
    if song['length']:
        minutes = song['length'] // 60
        seconds = song['length'] % 60
        duration = f" [{minutes}:{seconds:02d}]"
    
    # Format track number
    track = ""
    if song['track']:
        track = f"{song['track']:02d}. "
    
    # Format year
    year = ""
    if song['year']:
        year = f" ({song['year']})"
    
    return f"{track}{artist} - {title} ({albumartist} - {album}{year}){duration}"

# Display the current queue with highlighting for current song
def display_queue(queue, current_index=0):
    if not queue:
        print("Queue is empty.")
        return
    
    print(f"\n=== Audio Queue ({len(queue)} songs) ===")
    for i, song in enumerate(queue):
        marker = "â–¶ " if i == current_index else "  "
        print(f"{marker}{i+1:3d}. {format_song_info(song)}")
    print()

# Play songs in the queue
def play_queue(queue, shuffle=False, repeat=False, start_index=0):
    if not queue:
        print("Queue is empty. Nothing to play.")
        return
    
    # Create a copy of the queue for manipulation
    play_order = list(range(len(queue)))
    
    if shuffle:
        random.shuffle(play_order)
        print("Shuffle mode enabled.")
    if repeat:
        print("Repeat mode enabled.")
    current_index = start_index
    
    while True:
        try:
            # Get the current song index based on play order
            if shuffle:
                song_index = play_order[current_index % len(play_order)]
            else:
                song_index = current_index % len(queue)
            
            song = queue[song_index]
            
            # Display current queue status
            display_queue(queue, song_index)
            
            print(f"Now playing: {format_song_info(song)}")
            
            # Get the file path from the URL (remove file:// prefix if present)
            file_path = song['url']
            if file_path.startswith('file://'):
                file_path = file_path[7:]  # Remove 'file://' prefix
            
            # Check if file exists
            if not os.path.exists(file_path):
                print(f"Warning: File not found: {file_path}")
                print("Skipping to next song...")
                current_index += 1
                continue
            
            # Play the song
            success = play_audio(file_path)
            
            if not success:
                print("Error playing song. Skipping to next...")
            
            current_index += 1
            
            # Check if we've reached the end of the queue
            if current_index >= len(queue):
                if repeat:
                    current_index = 0
                    print("\nRepeating queue from the beginning...")
                else:
                    print("\nReached end of queue.")
                    break
                    
        except KeyboardInterrupt:
            print("\nPlayback interrupted by user.")
            user_input = input("Enter 'q' to quit, 'n' for next song, or any other key to continue: ").lower()
            if user_input == 'q':
                break
            elif user_input == 'n':
                current_index += 1
                continue
            else:
                continue
        except Exception as e:
            print(f"Error during playback: {e}")
            current_index += 1
            continue

# Interactive mode for queue management
def interactive_mode(conn):
    queue = []
    filters = {}
    
    print("\n=== Interactive Audio Queue Mode ===")
    print("Commands:")
    print("  list - Show all songs in library")
    print("  filter - Set filters (artist, album, genre)")
    print("  load - Load songs based on current filters")
    print("  show - Show current queue")
    print("  play - Play current queue")
    print("  shuffle - Toggle shuffle mode")
    print("  repeat - Toggle repeat mode")
    print("  clear - Clear current queue")
    print("  quit - Exit interactive mode")
    print()
    
    shuffle_mode = False
    repeat_mode = False
    
    while True:
        try:
            command = input("queue> ").strip().lower()
            
            if command == 'quit' or command == 'q':
                break
            elif command == 'list':
                songs = get_songs_from_database(conn)
                if songs:
                    print(f"\nFound {len(songs)} songs in library:")
                    for i, song in enumerate(songs[:20]):  # Show first 20
                        print(f"  {i+1:3d}. {format_song_info(song)}")
                    if len(songs) > 20:
                        print(f"  ... and {len(songs) - 20} more")
                else:
                    print("No songs found in library.")
            elif command == 'filter':
                print("Set filters (press Enter to skip):")
                artist = input("Artist: ").strip()
                album = input("Album: ").strip()
                genre = input("Genre: ").strip()
                
                filters = {}
                if artist:
                    filters['artist'] = artist
                if album:
                    filters['album'] = album
                if genre:
                    filters['genre'] = genre
                
                print(f"Filters set: {filters}")
            elif command == 'load':
                songs = get_songs_from_database(conn, filters)
                if songs:
                    queue = list(songs)
                    print(f"Loaded {len(queue)} songs into queue.")
                else:
                    print("No songs found matching current filters.")
            elif command == 'show':
                display_queue(queue)
            elif command == 'play':
                if queue:
                    play_queue(queue, shuffle_mode, repeat_mode)
                else:
                    print("Queue is empty. Use 'load' to add songs first.")
            elif command == 'shuffle':
                shuffle_mode = not shuffle_mode
                print(f"Shuffle mode: {'ON' if shuffle_mode else 'OFF'}")
            elif command == 'repeat':
                repeat_mode = not repeat_mode
                print(f"Repeat mode: {'ON' if repeat_mode else 'OFF'}")
            elif command == 'clear':
                queue = []
                print("Queue cleared.")
            elif command == 'help':
                print("Commands: list, filter, load, show, play, shuffle, repeat, clear, quit")
            else:
                print("Unknown command. Type 'help' for available commands.")
                
        except KeyboardInterrupt:
            print("\nExiting interactive mode...")
            break
        except Exception as e:
            print(f"Error: {e}")
# Main func
def main():
    parser = argparse.ArgumentParser(
        description="Audio Queue Manager - Play songs from your music library",
        epilog="Example: python audio_queue.py --artist 'Pink Floyd' --shuffle"
    )
    parser.add_argument(
        "--db-path",
        default=DEFAULT_DB_PATH,
        help=f"Path to the SQLite database file (default: {DEFAULT_DB_PATH})"
    )
    parser.add_argument(
        "--shuffle",
        action="store_true",
        help="Shuffle the queue"
    )
    parser.add_argument(
        "--repeat",
        action="store_true",
        help="Repeat the queue when it ends"
    )
    parser.add_argument(
        "--artist",
        help="Filter songs by artist name (partial match)"
    )
    parser.add_argument(
        "--album",
        help="Filter songs by album name (partial match)"
    )
    parser.add_argument(
        "--genre",
        help="Filter songs by genre (partial match)"
    )
    parser.add_argument(
        "--interactive",
        action="store_true",
        help="Start in interactive mode"
    )
    parser.add_argument(
        "--list",
        action="store_true",
        help="List all songs in the library and exit"
    )
    
    args = parser.parse_args()
    
    # Connect to database
    conn = connect_to_database(args.db_path)
    if not conn:
        sys.exit(1)
    
    try:
        # List mode - just show songs and exit
        if args.list:
            songs = get_songs_from_database(conn)
            if songs:
                print(f"Found {len(songs)} songs in library:")
                for i, song in enumerate(songs):
                    print(f"  {i+1:3d}. {format_song_info(song)}")
            else:
                print("No songs found in library.")
            return
        
        # Interactive mode
        if args.interactive:
            interactive_mode(conn)
            return
        
        # Build filters from command line arguments
        filters = {}
        if args.artist:
            filters['artist'] = args.artist
        if args.album:
            filters['album'] = args.album
        if args.genre:
            filters['genre'] = args.genre
        
        # Get songs from database
        songs = get_songs_from_database(conn, filters)
        
        if not songs:
            print("No songs found matching the specified criteria.")
            print("Use --list to see all available songs.")
            sys.exit(1)
        
        print(f"Found {len(songs)} songs matching criteria.")
        
        # Play the queue
        play_queue(list(songs), args.shuffle, args.repeat)
        
    except Exception as e:
        print(f"Error: {e}")
        sys.exit(1)
    finally:
        conn.close()

# Run file
if __name__ == "__main__":
    main()
