name: Build Walrio GUIs

on:
  # Manual trigger via "bot, build" comment
  issue_comment:
    types: [created]
  # Also trigger on PR events so workflow is available
  pull_request:
    types: [opened, synchronize, reopened]
  # Automatic builds when releases are published
  release:
    types: [published]
  # Manual workflow dispatch  
  workflow_dispatch:
    inputs:
      test_build:
        description: 'Test build trigger'
        required: false
        default: 'true'

permissions:
  contents: read
  pull-requests: write
  issues: write
  actions: read

jobs:
  build:
    # Run on "bot, build" comments or release publish or manual dispatch
    # PR events register workflow but don't trigger builds
    if: |
      (github.event_name == 'issue_comment' && 
       contains(github.event.comment.body, 'bot, build')) ||
      github.event_name == 'release' ||
      github.event_name == 'workflow_dispatch'
    
    strategy:
      matrix:
        os: [ubuntu-latest, macos-latest, windows-latest]
        gui-variant: ['main', 'lite']
    
    runs-on: ${{ matrix.os }}
    
    env:
      PYTHON_VERSION: '3.11'  # Fixed Python version for all builds
    
    steps:
    - name: React to comment
      if: github.event_name == 'issue_comment'
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const { comment } = context.payload;
          
          await github.rest.reactions.createForIssueComment({
            owner,
            repo,
            comment_id: comment.id,
            content: 'rocket'
          });

    - name: Get PR info
      if: github.event_name == 'issue_comment'
      id: pr-info
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const issueNumber = context.issue.number;
          
          const { data: pr } = await github.rest.pulls.get({
            owner,
            repo,
            pull_number: issueNumber
          });
          
          console.log(`PR #${pr.number}: ${pr.title}`);
          console.log(`Author: ${pr.user.login}`);
          console.log(`Head SHA: ${pr.head.sha}`);
          
          core.setOutput('pr_number', pr.number);
          core.setOutput('pr_title', pr.title);
          core.setOutput('pr_author', pr.user.login);
          core.setOutput('head_sha', pr.head.sha);
          core.setOutput('head_ref', pr.head.ref);

    - name: Post initial build status
      if: github.event_name == 'issue_comment'
      id: initial-comment
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const issueNumber = context.issue.number;
          
          const prNumber = '${{ steps.pr-info.outputs.pr_number }}';
          const author = '${{ steps.pr-info.outputs.pr_author }}';
          const runId = '${{ github.run_id }}';
          const repoUrl = `https://github.com/${owner}/${repo}`;
          const actionUrl = `${repoUrl}/actions/runs/${runId}`;
          const variant = '${{ matrix.gui-variant }}';
          const os = '${{ matrix.os }}';
          
          const message = `## ğŸš€ Build Bot Started

          Building Walrio GUIs for PR #${prNumber} by ` + '@' + `${author}

          ### ğŸ“Š Build Status:
          - âš ï¸ **${variant} on ${os}**: Starting build process...
          - âš ï¸ **Dependencies**: Installing platform-specific requirements
          - âš ï¸ **PyInstaller**: Preparing executable packaging
          - âš ï¸ **Artifacts**: Will be available when build completes
          
          *Building all GUI variants across all platforms... This message will be updated with results.*
          
          ğŸ”— **[Watch build progress live](${actionUrl})** - View real-time logs, error details, and complete build information
          
          ğŸ’¡ **Build Matrix**: This workflow builds both Main and Lite GUIs for Linux, macOS, and Windows (6 total builds)`;
          
          const { data: comment } = await github.rest.issues.createComment({
            owner,
            repo,
            issue_number: issueNumber,
            body: message
          });
          
          core.setOutput('comment_id', comment.id);

    - name: Checkout code
      uses: actions/checkout@v4
      with:
        # For comment triggers, checkout the PR head
        ref: ${{ github.event_name == 'issue_comment' && format('refs/pull/{0}/head', github.event.issue.number) || github.ref }}
      
    - name: Set up Python ${{ env.PYTHON_VERSION }}
      uses: actions/setup-python@v4
      with:
        python-version: ${{ env.PYTHON_VERSION }}
        
    - name: Cache pip dependencies
      uses: actions/cache@v4
      with:
        path: ~/.cache/pip
        key: ${{ runner.os }}-pip-${{ hashFiles('**/requirements.txt') }}
        restore-keys: |
          ${{ runner.os }}-pip-
          
    # Linux-specific setup
    - name: Install Linux dependencies
      if: runner.os == 'Linux'
      run: |
        sudo apt-get update
        sudo apt-get install -y \
          gstreamer1.0-tools \
          gstreamer1.0-plugins-base \
          gstreamer1.0-plugins-good \
          gstreamer1.0-plugins-bad \
          gstreamer1.0-plugins-ugly \
          gstreamer1.0-libav \
          libgstreamer1.0-dev \
          libgirepository1.0-dev \
          gobject-introspection \
          libcairo2-dev \
          libgtk-3-dev \
          build-essential \
          python3-dev \
          pkg-config \
          libffi-dev
        
        echo "Setting up Linux environment variables for GStreamer..."
        # Set up GStreamer environment variables
        echo "GST_PLUGIN_PATH=/usr/lib/x86_64-linux-gnu/gstreamer-1.0" >> $GITHUB_ENV
        echo "GI_TYPELIB_PATH=/usr/lib/x86_64-linux-gnu/girepository-1.0" >> $GITHUB_ENV
        
        # Export for current session
        export GST_PLUGIN_PATH="/usr/lib/x86_64-linux-gnu/gstreamer-1.0"
        export GI_TYPELIB_PATH="/usr/lib/x86_64-linux-gnu/girepository-1.0"
          
    # macOS-specific setup  
    - name: Install macOS dependencies
      if: runner.os == 'macOS'
      run: |
        echo "Installing macOS dependencies..."
        
        # Update homebrew
        brew update
        
        # Install core system dependencies first (required for PyGObject compilation)
        echo "Installing core system dependencies..."
        brew install python3 gobject-introspection libffi pkg-config cairo glib gtk+3
        
        # Install GStreamer and plugins
        echo "Installing GStreamer..."
        brew install gstreamer gst-plugins-base gst-plugins-good gst-plugins-bad gst-plugins-ugly
        
        # Set up essential environment variables for PyGObject
        echo "Setting up environment variables..."
        
        # Get Homebrew prefix (handles both Intel and Apple Silicon)
        BREW_PREFIX=$(brew --prefix)
        
        # Set PKG_CONFIG_PATH for libffi and other libraries
        echo "PKG_CONFIG_PATH=${BREW_PREFIX}/lib/pkgconfig:${BREW_PREFIX}/libffi/lib/pkgconfig:\$PKG_CONFIG_PATH" >> $GITHUB_ENV
        
        # Set library paths for dynamic linking
        echo "DYLD_LIBRARY_PATH=${BREW_PREFIX}/lib:\$DYLD_LIBRARY_PATH" >> $GITHUB_ENV
        echo "LD_LIBRARY_PATH=${BREW_PREFIX}/lib:\$LD_LIBRARY_PATH" >> $GITHUB_ENV
        
        # Set GI typelib path
        echo "GI_TYPELIB_PATH=${BREW_PREFIX}/lib/girepository-1.0:\$GI_TYPELIB_PATH" >> $GITHUB_ENV
        
        # Set GST plugin path  
        echo "GST_PLUGIN_PATH=${BREW_PREFIX}/lib/gstreamer-1.0:\$GST_PLUGIN_PATH" >> $GITHUB_ENV
        
        # Export for current shell session
        export PKG_CONFIG_PATH="${BREW_PREFIX}/lib/pkgconfig:${BREW_PREFIX}/libffi/lib/pkgconfig:$PKG_CONFIG_PATH"
        export DYLD_LIBRARY_PATH="${BREW_PREFIX}/lib:$DYLD_LIBRARY_PATH"
        export GI_TYPELIB_PATH="${BREW_PREFIX}/lib/girepository-1.0:$GI_TYPELIB_PATH"
        
        echo "macOS dependency installation completed successfully"
        
    # Windows-specific setup
    - name: Install Windows dependencies  
      if: runner.os == 'Windows'
      run: |
        Write-Host "=== Installing Windows Dependencies ==="
        
        # Install MSYS2 first - this is the most reliable way to get PyGObject on Windows
        Write-Host "Installing MSYS2..."
        choco install msys2 -y --force
        
        # Wait for installation to complete
        Start-Sleep -Seconds 10
        
        # Set up MSYS2 paths
        $env:PATH = "C:\tools\msys64\mingw64\bin;C:\tools\msys64\usr\bin;" + $env:PATH
        
        Write-Host "Updating MSYS2 package database..."
        C:\tools\msys64\usr\bin\bash.exe -lc "pacman -Syu --noconfirm"
        
        Write-Host "Installing GStreamer and PyGObject via MSYS2..."
        C:\tools\msys64\usr\bin\bash.exe -lc "pacman -S --noconfirm mingw-w64-x86_64-python mingw-w64-x86_64-python-gobject mingw-w64-x86_64-gstreamer mingw-w64-x86_64-gst-plugins-base mingw-w64-x86_64-gst-plugins-good mingw-w64-x86_64-gst-plugins-bad mingw-w64-x86_64-gst-plugins-ugly"
        
        Write-Host "Setting up environment variables for Windows PyGObject..."
        # Set environment variables for current session and future steps
        $msys64Path = "C:\tools\msys64\mingw64"
        
        # Add to PATH
        echo "PATH=${msys64Path}\bin;${env:PATH}" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        
        # Set PKG_CONFIG_PATH
        echo "PKG_CONFIG_PATH=${msys64Path}\lib\pkgconfig" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        
        # Set GI and GST paths
        echo "GI_TYPELIB_PATH=${msys64Path}\lib\girepository-1.0" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        echo "GST_PLUGIN_PATH=${msys64Path}\lib\gstreamer-1.0" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        
        # Set library paths
        echo "LD_LIBRARY_PATH=${msys64Path}\lib" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
        
        # Export for current session
        $env:PKG_CONFIG_PATH = "${msys64Path}\lib\pkgconfig"
        $env:GI_TYPELIB_PATH = "${msys64Path}\lib\girepository-1.0"
        $env:GST_PLUGIN_PATH = "${msys64Path}\lib\gstreamer-1.0"
        $env:LD_LIBRARY_PATH = "${msys64Path}\lib"
        $env:PATH = "${msys64Path}\bin;" + $env:PATH
        
        Write-Host "Verifying PyGObject installation..."
        # Test PyGObject import with system Python using MSYS2 libraries
        try {
          python -c "import gi; print('âœ“ PyGObject import successful')"
          python -c "import gi; gi.require_version('Gst', '1.0'); from gi.repository import Gst; print('âœ“ GStreamer import successful')"
          Write-Host "âœ“ PyGObject and GStreamer successfully available"
        } catch {
          Write-Host "âš ï¸ PyGObject import test failed: $($_.Exception.Message)"
          Write-Host "Will attempt conda-forge fallback..."
          
          # Install conda as fallback
          choco install miniconda3 -y
          $env:PATH = "C:\tools\miniconda3;C:\tools\miniconda3\Scripts;C:\tools\miniconda3\condabin;" + $env:PATH
          
          & C:\tools\miniconda3\Scripts\conda.exe config --set always_yes true
          & C:\tools\miniconda3\Scripts\conda.exe install -c conda-forge pygobject gtk gstreamer
          
          Write-Host "PyGObject installed via conda-forge fallback"
        }
        
        Write-Host "Windows dependencies installation completed"
        
    - name: Install Python dependencies (non-Linux)
      if: runner.os != 'Linux'
      run: |
        python -m pip install --upgrade pip
        pip install -r requirements.txt
        pip install pyinstaller
        
    - name: Install Python dependencies (Linux)
      if: runner.os == 'Linux'
      run: |
        python -m pip install --upgrade pip
        # Install everything except PyGObject from requirements.txt
        pip install mutagen PySide6 Pillow
        pip install pyinstaller
        
    - name: Install additional build dependencies (macOS)
      if: runner.os == 'macOS'
      run: |
        # Install Python dependencies
        pip install PySide6 mutagen
        
        # Install PyGObject with proper environment
        echo "Installing PyGObject with proper environment setup..."
        
        # Ensure environment variables are available
        BREW_PREFIX=$(brew --prefix)
        export PKG_CONFIG_PATH="${BREW_PREFIX}/lib/pkgconfig:${BREW_PREFIX}/libffi/lib/pkgconfig:$PKG_CONFIG_PATH"
        export DYLD_LIBRARY_PATH="${BREW_PREFIX}/lib:$DYLD_LIBRARY_PATH"
        
        # Install PyGObject
        pip install PyGObject
        
        # Verify installation
        python3 -c "import gi; print('PyGObject import successful')"
        python3 -c "import gi; gi.require_version('GLib', '2.0'); from gi.repository import GLib; print('GLib import successful')"
        
    - name: Install additional build dependencies (Windows)
      if: runner.os == 'Windows'
      run: |
        # Check if MSYS2 Python is available
        $msys2Python = "C:\tools\msys64\ucrt64\bin\python.exe"
        if (Test-Path $msys2Python) {
          Write-Host "MSYS2 Python found, setting up environment for system Python to access MSYS2 PyGObject"
          
          # Add MSYS2 paths to system PATH for library discovery
          $env:PATH = "C:\tools\msys64\ucrt64\bin;C:\tools\msys64\usr\bin;" + $env:PATH
          
          # Set up library paths for PyGObject
          $env:PKG_CONFIG_PATH = "C:\tools\msys64\ucrt64\lib\pkgconfig"
          $env:GI_TYPELIB_PATH = "C:\tools\msys64\ucrt64\lib\girepository-1.0"
          
          # Add MSYS2 Python site-packages to system Python path
          $msys2SitePackages = "C:\tools\msys64\ucrt64\lib\python3.11\site-packages"
          $env:PYTHONPATH = "$msys2SitePackages;" + $env:PYTHONPATH
          
          # Persist environment variables for subsequent steps
          echo "PATH=C:\tools\msys64\ucrt64\bin;C:\tools\msys64\usr\bin;$env:PATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "PKG_CONFIG_PATH=C:\tools\msys64\ucrt64\lib\pkgconfig" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "GI_TYPELIB_PATH=C:\tools\msys64\ucrt64\lib\girepository-1.0" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          echo "PYTHONPATH=$msys2SitePackages;$env:PYTHONPATH" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          
          # Use system Python with access to MSYS2 libraries
          pip install PySide6 mutagen pyinstaller
          
          # Test PyGObject import
          python -c "import gi; print('PyGObject import successful via MSYS2 path')"
          
          Write-Host "Configured system Python to use MSYS2 PyGObject"
        } else {
          Write-Host "Using system Python (conda fallback was used)"
          pip install PySide6 mutagen pyinstaller
        }
        
    # Linux: Install PyGObject via system packages (more reliable)
    - name: Install PyGObject (Linux)
      if: runner.os == 'Linux'  
      run: |
        # Install PyGObject from system packages (already installed in Linux dependencies step)
        echo "PyGObject system packages already installed"
        # Verify installation
        python3 -c "import gi; print('PyGObject system installation successful')" || echo "PyGObject verification failed"

    - name: Comprehensive GStreamer verification
      run: |
        echo "=== Comprehensive GStreamer/PyGObject Verification ==="
        
        # Print environment variables
        echo "Environment variables:"
        echo "  GST_PLUGIN_PATH: ${GST_PLUGIN_PATH:-Not set}"
        echo "  GI_TYPELIB_PATH: ${GI_TYPELIB_PATH:-Not set}"
        echo "  PKG_CONFIG_PATH: ${PKG_CONFIG_PATH:-Not set}"
        
        # Test basic Python imports
        echo "Testing Python gi import..."
        python -c "import sys; print('Python version:', sys.version)"
        
        echo "Testing PyGObject import..."
        python -c "import gi; print('âœ“ gi import successful')" || echo "âŒ gi import failed"
        
        echo "Testing GStreamer import..."
        python -c "import gi; gi.require_version('Gst', '1.0'); from gi.repository import Gst; print('âœ“ GStreamer import successful')" || echo "âŒ GStreamer import failed"
        
        echo "Testing GStreamer initialization..."
        python -c "import gi; gi.require_version('Gst', '1.0'); from gi.repository import Gst; result = Gst.init_check(None); print('âœ“ GStreamer initialization successful' if result else 'âš ï¸ GStreamer initialization failed')" || echo "âŒ GStreamer initialization test failed"
        
        echo "Verification completed."
        
    - name: Run dependency check
      continue-on-error: true
      run: |
        make deps-check
        
    - name: Build GUI (${{ matrix.gui-variant }})
      run: |
        make build-${{ matrix.gui-variant }}
        
    - name: Test built executable (Linux/macOS)
      if: runner.os != 'Windows'
      run: |
        # Test that the specific executable was created
        VARIANT="${{ matrix.gui-variant }}"
        if [ "$VARIANT" = "main" ]; then
          EXPECTED_FILE="dist/WalrioMain"
        else
          EXPECTED_FILE="dist/WalrioLite"
        fi
        
        if [ -f "$EXPECTED_FILE" ]; then
          echo "âœ“ $EXPECTED_FILE found"
        else
          echo "âœ— $EXPECTED_FILE not found"
          ls -la dist/ || echo "dist/ directory not found"
          exit 1
        fi
        
    - name: Test built executable (Windows)
      if: runner.os == 'Windows'
      run: |
        $variant = "${{ matrix.gui-variant }}"
        if ($variant -eq "main") {
          $expectedFile = "dist/WalrioMain.exe"
        } else {
          $expectedFile = "dist/WalrioLite.exe"
        }
        
        if (Test-Path $expectedFile) {
          Write-Host "âœ“ $expectedFile found"
        } else {
          Write-Host "âœ— $expectedFile not found"
          Get-ChildItem dist/ -ErrorAction SilentlyContinue | Format-Table
          exit 1
        }
    
    - name: Test PyGObject bundling
      continue-on-error: true
      run: |
        echo "Testing PyGObject import capability in built environment..."
        
        # Test if gi can be imported in the current Python environment
        if python -c "import gi; print('âœ“ gi import successful')"; then
          echo "âœ“ PyGObject available in build environment"
        else
          echo "âš ï¸ PyGObject not available in build environment - executable may have import issues"
        fi
        
        # Additional GStreamer test
        if python -c "import gi; gi.require_version('Gst', '1.0'); from gi.repository import Gst; print('âœ“ GStreamer import successful')"; then
          echo "âœ“ GStreamer available in build environment"
        else
          echo "âš ï¸ GStreamer not available in build environment - audio may not work"
        fi
        
    - name: Create artifact name
      id: artifact
      run: |
        OS_NAME="${{ runner.os }}"
        if [ "$OS_NAME" = "Linux" ]; then
          OS_NAME="linux"
        elif [ "$OS_NAME" = "Windows" ]; then
          OS_NAME="windows"  
        elif [ "$OS_NAME" = "macOS" ]; then
          OS_NAME="macos"
        fi
        
        VARIANT="${{ matrix.gui-variant }}"
        VARIANT_UPPER=$(echo "$VARIANT" | tr '[:lower:]' '[:upper:]')
        
        echo "name=WALRIO_${VARIANT_UPPER}-${OS_NAME}" >> $GITHUB_OUTPUT
      shell: bash

    - name: Update build completion status
      if: github.event_name == 'issue_comment'
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const issueNumber = context.issue.number;
          const runId = '${{ github.run_id }}';
          const variant = '${{ matrix.gui-variant }}';
          const os = '${{ matrix.os }}';
          const artifactName = '${{ steps.artifact.outputs.name }}';
          
          const message = `âœ… **Build completed for ${variant} on ${os}**
          
          ğŸ“¦ Successfully built Walrio ${variant} GUI for ${os}
          
          ï¿½ **Artifact**: \`${artifactName}\`
          ğŸ”— **[Download from Actions](https://github.com/${owner}/${repo}/actions/runs/${runId})**
          
          *This build is complete and artifacts are ready for download.*`;
          
          await github.rest.issues.createComment({
            owner,
            repo,
            issue_number: issueNumber,
            body: message
          });

    - name: Comment on build failure
      if: failure() && github.event_name == 'issue_comment'
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const issueNumber = context.issue.number;
          const runId = '${{ github.run_id }}';
          const variant = '${{ matrix.gui-variant }}';
          const os = '${{ matrix.os }}';
          
          const message = `âŒ **Build failed for ${variant} on ${os}**
          
          ğŸ’¥ Failed to build Walrio ${variant} GUI for ${os}
          
          ğŸ” **[View error logs](https://github.com/${owner}/${repo}/actions/runs/${runId})**
          
          *Please check the build logs for detailed error information.*`;
          
          await github.rest.issues.createComment({
            owner,
            repo,
            issue_number: issueNumber,
            body: message
          });
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: ${{ steps.artifact.outputs.name }}
        path: |
          dist/
          !dist/**/*.spec
        retention-days: 30
        
  release:
    if: github.event_name == 'release'
    needs: build
    runs-on: ubuntu-latest
    
    steps:
    - name: Download all artifacts
      uses: actions/download-artifact@v4
      with:
        pattern: "WALRIO_*-*"
        merge-multiple: false
      
    - name: Create release archives
      run: |
        # Create archives for each variant and platform
        for artifact_dir in */; do
          if [ -d "$artifact_dir" ]; then
            # Remove trailing slash
            dir_name="${artifact_dir%/}"
            
            # Skip if not our artifact naming pattern
            if [[ ! "$dir_name" =~ ^WALRIO_(MAIN|LITE)-(linux|macos|windows)$ ]]; then
              continue
            fi
            
            # Create appropriate archive format
            if [[ "$dir_name" == *"windows"* ]]; then
              # Windows: create .zip files
              cd "$artifact_dir"
              zip -r "../${dir_name}.zip" .
              cd ..
            else
              # Linux/macOS: create .tar.gz files  
              tar -czf "${dir_name}.tar.gz" -C "$artifact_dir" .
            fi
            
            echo "Created archive for $dir_name"
          fi
        done
        
        # List created archives
        ls -la *.zip *.tar.gz 2>/dev/null || echo "No archives created"
        
    - name: Create Release
      uses: softprops/action-gh-release@v1
      with:
        files: |
          *.zip
          *.tar.gz
        draft: true
        prerelease: ${{ contains(github.ref, 'alpha') || contains(github.ref, 'beta') || contains(github.ref, 'rc') }}
        generate_release_notes: true
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  # Summary job for comment-triggered builds
  build-summary:
    if: github.event_name == 'issue_comment' && github.event.issue.pull_request && contains(github.event.comment.body, 'bot, build')
    needs: build
    runs-on: ubuntu-latest
    
    steps:
    - name: Post final build summary
      uses: actions/github-script@v7
      with:
        script: |
          const { owner, repo } = context.repo;
          const issueNumber = context.issue.number;
          const runId = '${{ github.run_id }}';
          const repoUrl = `https://github.com/${owner}/${repo}`;
          const actionUrl = `${repoUrl}/actions/runs/${runId}`;
          
          // Get build job results
          const jobs = await github.rest.actions.listJobsForWorkflowRun({
            owner,
            repo,
            run_id: runId
          });
          
          const buildJobs = jobs.data.jobs.filter(job => job.name.includes('build ('));
          const successfulBuilds = buildJobs.filter(job => job.conclusion === 'success');
          const failedBuilds = buildJobs.filter(job => job.conclusion === 'failure');
          
          let message = `## ğŸ Build Summary Complete\n\n`;
          message += `### ğŸ“Š Final Results:\n`;
          message += `- âœ… **Successful builds**: ${successfulBuilds.length}/${buildJobs.length}\n`;
          
          if (successfulBuilds.length > 0) {
            message += `\n### âœ… Successful Builds:\n`;
            successfulBuilds.forEach(job => {
              const jobName = job.name.replace('build (', '').replace(')', '');
              message += `- **${jobName}**: Build completed successfully\n`;
            });
          }
          
          if (failedBuilds.length > 0) {
            message += `\n### âŒ Failed Builds:\n`;
            failedBuilds.forEach(job => {
              const jobName = job.name.replace('build (', '').replace(')', '');
              message += `- **${jobName}**: Build failed ([view logs](${actionUrl}))\n`;
            });
          }
          
          message += `\n### ğŸ“¦ Artifacts:\n`;
          if (successfulBuilds.length > 0) {
            message += `- **[Download all artifacts](${actionUrl})** - Available for 30 days\n`;
            message += `- Artifacts are named: \`WALRIO_MAIN-{platform}\` and \`WALRIO_LITE-{platform}\`\n`;
          } else {
            message += `- No artifacts available (all builds failed)\n`;
          }
          
          message += `\n---\n\n`;
          message += `ğŸ”— **[View complete build logs](${actionUrl})**\n\n`;
          
          if (successfulBuilds.length === buildJobs.length) {
            message += `ğŸ‰ **All builds completed successfully!** Ready for download.\n`;
          } else if (successfulBuilds.length > 0) {
            message += `âš ï¸ **Partial success** - Some builds failed, but ${successfulBuilds.length} completed successfully.\n`;
          } else {
            message += `ğŸ’¥ **All builds failed** - Please check the logs and try again.\n`;
          }
          
          message += `\n*To trigger another build, comment: "bot, build"*`;
          
          await github.rest.issues.createComment({
            owner,
            repo,
            issue_number: issueNumber,
            body: message
          });