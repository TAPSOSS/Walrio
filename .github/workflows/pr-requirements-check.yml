name: PR Requirements Check

on:
  pull_request:
    branches: [ main ]
    types: [opened, edited, synchronize, reopened]
  repository_dispatch:
    types: [bot-check]

permissions:
  pull-requests: write
  issues: write
  contents: read
  actions: read

jobs:
  check-pr-requirements:
    runs-on: ubuntu-latest
    
    steps:
    - name: Check PR Requirements
      uses: actions/github-script@v7
      with:
        script: |
          const { data: pr } = await github.rest.pulls.get({
            owner: context.repo.owner,
            repo: context.repo.repo,
            pull_number: context.issue.number
          });

          const title = pr.title;
          const body = pr.body || '';
          
          let errors = [];
          let warnings = [];

          // Check 1: PR Title Guidelines
          const titlePatterns = [
            /^Added .+: .+$/,
            /^Bug Fix .+: .+$/,
            /^Updated .+: .+$/,
            /^Documentation: .+$/
          ];
          
          const titleValid = titlePatterns.some(pattern => pattern.test(title));
          if (!titleValid) {
            console.log('‚ùå PR Title check failed');
            console.log(`Current title: "${title}"`);
            errors.push('‚ùå **PR Title**: Title does not follow the required format. Please use one of:\n' +
                       '   - "Added [word]: [description]" - for new features\n' +
                       '   - "Bug Fix [word]: [description]" - for bug fixes\n' +
                       '   - "Updated [word]: [description]" - for updates\n' +
                       '   - "Documentation: [description]" - for documentation only');
          } else {
            console.log('‚úÖ PR Title format is correct');
          }

          // Check 2: Description has content (at least 1 character after the template)
          console.log('üîç Checking description...');
          const descriptionSection = body.match(/## Description\s*\n.*?\n(.*?)(?=\n##|$)/s);
          let description = descriptionSection ? descriptionSection[1].trim() : '';
          
          console.log(`Raw description section found: ${!!descriptionSection}`);
          console.log(`Description before cleaning: "${description}"`);
          
          // Remove any HTML comments from the description
          description = description.replace(/<!--[\s\S]*?-->/g, '').trim();
          
          console.log(`Description after cleaning: "${description}"`);
          console.log(`Description length: ${description.length}`);
          
          // Check if description is empty or contains only whitespace/newlines
          if (!description || description.length < 1 || description.match(/^\s*$/)) {
            console.log('‚ùå Description check failed - no content found');
            errors.push('‚ùå **Description**: Please provide a description of your changes in the Description section.');
          } else {
            console.log('‚úÖ Description provided');
          }

          // Check 3: At least one "Type of Change" box checked
          console.log('üîç Checking Type of Change...');
          const typeOfChangeSection = body.match(/## Type of Change.*?\n(.*?)(?=\n##|$)/s);
          const typeOfChangeChecked = typeOfChangeSection && (typeOfChangeSection[1].includes('- [x]') || typeOfChangeSection[1].includes('- [X]'));
          
          console.log(`Type of Change section found: ${!!typeOfChangeSection}`);
          if (typeOfChangeSection) {
            console.log(`Type of Change content: "${typeOfChangeSection[1]}"`);
          }
          
          if (!typeOfChangeChecked) {
            console.log('‚ùå Type of Change check failed');
            errors.push('‚ùå **Type of Change**: Please check at least one box in the "Type of Change" section.');
          } else {
            console.log('‚úÖ Type of Change selected');
          }

          // Check 4: All checklist items checked
          console.log('üîç Checking Checklist...');
          const checklistSection = body.match(/## Checklist.*?\n(.*?)(?=\n##|$)/s);
          if (checklistSection) {
            const checklistItems = checklistSection[1].match(/- \[[ xX]\]/g) || [];
            const checkedItems = checklistSection[1].match(/- \[[xX]\]/g) || [];
            
            console.log(`Found ${checklistItems.length} checklist items, ${checkedItems.length} checked`);
            
            if (checklistItems.length === 0) {
              console.log('‚ö†Ô∏è No checklist items found');
              warnings.push('‚ö†Ô∏è **Checklist**: No checklist items found.');
            } else if (checkedItems.length < checklistItems.length) {
              const uncheckedCount = checklistItems.length - checkedItems.length;
              console.log(`‚ùå Checklist check failed - ${uncheckedCount} items unchecked`);
              errors.push(`‚ùå **Checklist**: ${uncheckedCount} checklist item(s) not checked off. Please complete all checklist items.`);
            } else {
              console.log('‚úÖ All checklist items completed');
            }
          } else {
            console.log('‚ö†Ô∏è Checklist section not found');
            warnings.push('‚ö†Ô∏è **Checklist**: Checklist section not found.');
          }

          // Summary of all checks
          console.log('\nüìã Check Summary:');
          console.log(`Total errors: ${errors.length}`);
          console.log(`Total warnings: ${warnings.length}`);
          
          if (errors.length > 0) {
            console.log('\n‚ùå Errors found:');
            errors.forEach((error, index) => {
              console.log(`${index + 1}. ${error.split('\n')[0]}`);
            });
          }
          
          if (warnings.length > 0) {
            console.log('\n‚ö†Ô∏è Warnings found:');
            warnings.forEach((warning, index) => {
              console.log(`${index + 1}. ${warning}`);
            });
          }

          // Create status comment
          let commentBody = '## ü§ñ PR Requirements Check\n\n';
          
          if (errors.length === 0) {
            commentBody += '‚úÖ **All requirements met!** This PR follows all the guidelines.\n\n';
          } else {
            commentBody += '‚ùå **Issues found that need to be addressed:**\n\n';
            errors.forEach(error => {
              commentBody += error + '\n\n';
            });
          }

          if (warnings.length > 0) {
            commentBody += '‚ö†Ô∏è **Warnings:**\n\n';
            warnings.forEach(warning => {
              commentBody += warning + '\n\n';
            });
          }

          commentBody += '---\n*This check runs automatically when you open or update a PR. Please address any issues above.*';

          // Find existing bot comment
          const { data: comments } = await github.rest.issues.listComments({
            owner: context.repo.owner,
            repo: context.repo.repo,
            issue_number: context.issue.number
          });

          const botComment = comments.find(comment => 
            comment.user.type === 'Bot' && 
            comment.body.includes('ü§ñ PR Requirements Check')
          );

          if (botComment) {
            // Update existing comment
            await github.rest.issues.updateComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              comment_id: botComment.id,
              body: commentBody
            });
          } else {
            // Create new comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: commentBody
            });
          }

          // Set the job status
          if (errors.length > 0) {
            console.log(`\nüí• FAILING CHECK: Found ${errors.length} error(s)`);
            errors.forEach((error, index) => {
              console.log(`Error ${index + 1}: ${error.split('\n')[0]}`);
            });
            core.setFailed(`PR requirements check failed: ${errors.length} error(s) found. Check logs above for details.`);
          } else {
            console.log('‚úÖ All PR requirements satisfied');
          }
